// GoBalloon
// compressed.go - Functions for created and decoding compressed APRS position reports
//
// (c) 2014, Christopher Snell

package aprs

import (
	"bytes"
	"fmt"
	"github.com/chrissnell/GoBalloon/geospatial"
	"math"
	"strconv"
)

func CreateUncompressedPositionReportWithoutTimestamp(p *geospatial.Point, symTable, symCode rune, messaging bool) (string, error) {
	var buffer bytes.Buffer
	var lat_hem, lon_hem rune

	if messaging {
		buffer.WriteRune('=')
	} else {
		buffer.WriteRune('!')
	}

	if math.Abs(p.Lat) > 90 {
		return "", fmt.Errorf("Latitude is > +/- 90 degrees: %v\n", p.Lat)
	}

	if math.Abs(p.Lon) > 180 {
		return "", fmt.Errorf("Longitude is > +/- 180 degrees: %v\n", p.Lon)
	}

	if p.Lat > 0 {
		lat_hem = 'N'
	} else {
		lat_hem = 'S'
	}

	if p.Lon > 0 {
		lon_hem = 'E'
	} else {
		lon_hem = 'W'
	}

	buffer.WriteString(geospatial.LatDecimalDegreesToDegreesDecimalMinutes(math.Abs(p.Lat)))
	buffer.WriteRune(lat_hem)

	buffer.WriteRune(symTable)

	buffer.WriteString(geospatial.LonDecimalDegreesToDegreesDecimalMinutes(math.Abs(p.Lon)))
	buffer.WriteRune(lon_hem)

	buffer.WriteRune(symCode)

	return buffer.String(), nil
}

func CreateCompressedPositionReport(p *geospatial.Point, symTable, symCode rune) string {
	var buffer bytes.Buffer

	// First byte in our compressed position report is the data type indicator.
	// The rune '!' indicates a real-time compressed position report
	buffer.WriteRune('!')

	// Next byte is the symbol table selector
	buffer.WriteRune(symTable)

	// Next four bytes is the decimal latitude, compressed with funky Base91
	buffer.WriteString(string(EncodeBase91Position(int(LatPrecompress(p.Lat)))))

	// Then comes the longitude, same compression
	buffer.WriteString(string(EncodeBase91Position(int(LonPrecompress(p.Lon)))))

	// Then our symbol code
	buffer.WriteRune(symCode)

	// Then we compress our altitude with a funky logrithm and conver to Base91
	buffer.Write(AltitudeCompress(p.Altitude))

	// This last byte specifies: a live GPS fix, in GGA NMEA format, with the
	// compressed position generated by software (this program!).  See APRS
	// Protocol Reference v1.0, page 39, for more details on this wack shit.
	buffer.WriteByte(byte(0x32) + 33)

	return buffer.String()
}

func DecodeCompressedPositionReport(c string) (*geospatial.Point, rune, rune, error) {
	var err error
	s := []byte(c)

	p := &geospatial.Point{}
	if len(c) != 14 {
		return p, ' ', ' ', fmt.Errorf("Compressed position has invalid length.  Should be 14, is %v.\n", len(c))
	}

	symTable := rune(s[1])
	symCode := rune(s[10])

	p.Lat, err = DecodeBase91Lat(s[2:6])
	if err != nil {
		return p, ' ', ' ', fmt.Errorf("Could not decode compressed latitude: %v\n", err)
	}

	p.Lon, err = DecodeBase91Lon(s[6:10])
	if err != nil {
		return p, ' ', ' ', fmt.Errorf("Could not decode compressed longitude: %v\n", err)
	}

	p.Altitude, err = DecodeBase91Altitude(s[11:13])
	if err != nil {
		return p, ' ', ' ', fmt.Errorf("Could not decode compressed altitude: %v\n", err)
	}

	return p, symTable, symCode, nil
}

func DecodeUncompressedPositionReport(c string) (*geospatial.Point, rune, rune, error) {
	// Example:   !4903.50N/07201.75W-

	var err error

	p := &geospatial.Point{}

	symTable := rune(c[9])
	symCode := rune(c[19])

	la1, err := strconv.ParseFloat(c[1:3], 64)
	if err != nil {
		return p, symTable, symCode, err
	}
	la2, err := strconv.ParseFloat(c[3:7], 64)
	if err != nil {
		return p, symTable, symCode, err
	}

	lat := la1 + la2/60
	if c[8] == 'S' {
		lat = 0 - lat
	}

	lo1, err := strconv.ParseFloat(c[10:13], 64)
	if err != nil {
		return p, symTable, symCode, err
	}
	lo2, err := strconv.ParseFloat(c[13:18], 64)
	if err != nil {
		return p, symTable, symCode, err
	}

	lon := lo1 + lo2/60

	if c[18] == 'W' {
		lon = 0 - lon
	}

	p.Lat = lat
	p.Lon = lon
	return p, symTable, symCode, nil
}
